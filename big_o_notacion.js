// Big O Notation
//  Классическое понятие - 
// Асимптотическая сложность алгоритма -
// О(n), где n - размер входных данных
// Иными словами - способ описать, как будет расти время
// выполнения алгоритма в зависимости от роста входных данных

// Константная сложность 0(1) Время выполнения не зависит от размера данных

function getFirstElement(arr) {
    return arr[0];
}
console.log(getFirstElement([1, 2, 3, 4, 5]));

// Результат кода: 1

const array2 = new Array(10000000).fill("test");
console.log(getFirstElement(array2));

// Результат кода: test

// Линейная сложность О(n) Время выполнения растёт линейно с ростом входных данных
// если 'n' удваивается, время выполнения тоже удваивается
console.log("----O(n) Линейная сложность---");

// Пример - найти сумму всех чисел в массиве
// чтобы найти сумму, нужно пройтись по КАЖДОМУ элементу массива

function sumArray(arr) {
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}

console.log(sumArray([1, 2, 3, 4, 5]));

// Результат 15

const array1 = new Array(1000000).fill(1);
console.log(sumArray(array1));

// Результат 1000000

// O(n^2) - Квадратичная сложность
// Время выполнения растёт квадратично с ростом входных данных
// усли 'n' удваивается, время выполнения увеличивается в 4 раза
console.log("---O(n^2) Квадратичная сложность");

// Пример - найти все дубликаты в массиве

function hasDuplicates(arr) {
    const  n = arr.length;
    for (let i = 0; i < n; i++) { //Внешний цикл выполняется n раз
        for(let j = i + 1; j < n; j++) { //Внутренний цикл тоже выполняется n раз
            if(i !== j && arr[i] === arr[j]) {
                return true; //Найден дубликат
            }
        }
    }
    return false; // Дубликаты не найдены
}

console.log(hasDuplicates([1, 2, 3, 4, 5]));//false
console.log(hasDuplicates([1, 2, 3, 4, 5, 3])); //true

// логарифмическая сложность O(log n)
// Время выполнения растет логарифмически с ростом входных данных
// если 'n' удваивается, время выполнения увеливается на 1
console.log("---O(log.n) Логарифмическая сложность");

/**
 * Пример = бинарный поиск в отсортированном массиве
 * Бинарный поиск работает по принципу "разделяй и властвуй"
 * Он делит массив пополам и определяет, в какой половине
 * может находиться искомый элемент, затем повторяет процесс для этой половины.
 */
 function binarySearch(sortedArray, target) {
    let left = 0;
    let right = sortedArray.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (sortedArray[mid] === target) {
            return mid; // Элемент найден
        }
        if (sortedArray[mid] < target) {
            left = mid + 1; // Искомый элемент в правой половине

         } else {
            right = mid - 1; // Искомый элемент в левой половине
         }
    }
    
         return -1; // Элемент не найден
    
    } //количество итераций будет логарифмическим от размера массива
 
    const sortedNumbers = [2, 4, 7, 12, 14, 23, 45, 56,110];
    console.log(binarySearch(sortedNumbers, 23))
    console.log(binarySearch(sortedNumbers, 24))

    // ==============================================================
    // Линейно-логарифмическая сложность О(n log n)
    // Время выполнения растёт как nlog n с ростом входных данных
    // "Золотая середина" между О(n) и O(n^2)
    // Большинство эффективных алгоритмов сортировки имеют такую сложность
    console.log("---O(n log n)  Линейно-логарифмическая сложность---");

    // Пример. Сортировка массива.
    // Используем встроенный метод sort, который обычно реализован в большинстве движков JS

    function sortArray(arr) {
        // Мы здесь не пишем свой алгоритм сортировки,
        // а используем встроенный метод
        return arr.slice().sort((a, b) => a - b); //slice() чтобы не мутировать исходный массив
    }

    const unsortedArray = [5, 3, 8, 1, 2, 7];
    console.log("Сортировка исходного массива", sortArray(unsortedArray));

    // ==================================================================
    // Экспоненциальная сложность O(2^n)
    // Время выполнения удваивается с каждым добавлением элемента к входным данным

    console.log("---O(2^n) Экспоненциальная сложность----");

    // Пример - рекурсивное вычисление чисел Фибоначчи

    function fibonacci(n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2); //Два рекурсивных вызова

    }
    console.log(fibonacci(5)); //5

    // Факториальная сложность O(n!)
    // Время выполнения растёт факториально с ростом входных данных
    // Ужасно неэффективно для больших n
    console.log("---O(n!) Факториальная сложность---");

    // Пример = генерация всех перестановок массива

    function findPermutation(arr) {
        if (arr.length === 0) {
            return;
        }
        for (let i = 0 ; i < arr.length; i++) {
            const rest = arr.slice(0, 1).concat(arr.slice(i + 1));
            findPermutation(rest);
        }
    }

    console.log("Поиск перестановок массива [1, 2, 3] (n=3, n! = 6 перестановок)");
    findPermutation([1, 2, 3]); //6 перестановок
    //findPermutation([1, 2, 3, 4, 5, 6, 7]); //5040 перестановок - браузер зависает